TraceSegmentServiceClient
	->boot()
		->carrier = new DataCarrier<TraceSegment>(CHANNEL_SIZE, BUFFER_SIZE);                                                                       // 初始化 CHANNEL_SIZE = 5 个 channel 与 BUFFER_SIZE = 100 个 TraceSegment 的一个 DataCarrier 数据搬运工
			->this.name = name;
			->this.bufferSize = EnvUtil.getInt(envPrefix + "_BUFFER_SIZE", bufferSize);
			->this.channelSize = EnvUtil.getInt(envPrefix + "_CHANNEL_SIZE", channelSize);
			->channels = new Channels<T>(channelSize, bufferSize, new SimpleRollingPartitioner<T>(), BufferStrategy.BLOCKING);
                ->this.dataPartitioner = partitioner;
                ->this.strategy = strategy;
                ->bufferChannels = new Buffer[channelSize];
                ->for (int i = 0; i < channelSize; i++) {
                ->    bufferChannels[i] = new Buffer<T>(bufferSize, strategy);
                ->}
                ->size = channelSize * bufferSize;                                                                                                  //缓存大小
        ->carrier.setBufferStrategy(BufferStrategy.IF_POSSIBLE);                                                                                    //设置策略 阻塞还是异步
        ->carrier.consume(this, 1);                                                                                                                 //把TraceSegmentServiceClient的object 放进
			->this.consume(consumer, num, 20);
				->driver = new ConsumeDriver<T>(this.name, this.channels, consumer, num, consumeCycle);												//Thread.sleep(consumeCycle);
				    ->this(channels, num);
					->prototype.init();
					->for (int i = 0; i < num; i++) {
					->  consumerThreads[i] = new ConsumerThread("DataCarrier." + name + ".Consumser." + i + ".Thread", prototype, consumeCycle);    //初始化消费者线程
                    ->  consumerThreads[i].setDaemon(true);
                    ->}
				->driver.begin(channels);
GRPCChannelManager
    ->boot()
        ->grpcServers = Arrays.asList(Config.Collector.BACKEND_SERVICE.split(","));
        ->connectCheckFuture = Executors                                                                                                            //初始化 GRPCChannelManager 的线程
        .newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory("GRPCChannelManager"))
        .scheduleAtFixedRate(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {
          @Override
          public void handle(Throwable t) {
              logger.error("unexpected exception.", t);
          }
        }), 0, Config.Collector.GRPC_CHANNEL_CHECK_INTERVAL, TimeUnit.SECONDS);
JVMService
	->prepare
		->queue = new LinkedBlockingQueue<JVMMetric>(Config.Jvm.BUFFER_SIZE);
        ->sender = new Sender();
        ->ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(sender);
	->boot	
		->collectMetricFuture = Executors
            .newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory("JVMService-produce"))
            .scheduleAtFixedRate(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {
                @Override public void handle(Throwable t) {
                    logger.error("JVMService produces metrics failure.", t);
                }
            }), 0, 1, TimeUnit.SECONDS);
        ->sendMetricFuture = Executors
            .newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory("JVMService-consume"))
            .scheduleAtFixedRate(new RunnableWithExceptionProtection(sender, new RunnableWithExceptionProtection.CallbackWhenException() {
                @Override public void handle(Throwable t) {
                    logger.error("JVMService consumes and upload failure.", t);
                }
            }
            ), 0, 1, TimeUnit.SECONDS);