记住程序不知道怎么决定是应该配置默认

agent 启动逻辑
SkyWalkingAgent#premain
    SnifferConfigInitializer.initialize(agentArgs);//读取参数,从配置与环境变量里读取
    pluginFinder = new PluginFinder(new PluginBootstrap().loadPlugins());//用 AgentClassLoader 去加载插件,读取 plugin 下的jar 包 以及读取 skywalking-plugin.def 内容

客户端向服务端发送数据逻辑
TracingContext#
stopSpan
    finish();
        if (isRunningInAsyncMode)//判断是否在异步模式下
        if (activeSpanStack.isEmpty() && running && (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)) {//
        TraceSegment finishedSegment = segment.finish(isLimitMechanismWorking());//限定发送数据的是否工作
             if (spanIdGenerator >= Config.Agent.SPAN_LIMIT_PER_SEGMENT) { //判断配置限定每个segment的可容纳多少个span是否超过限制的
        if (!segment.hasRef() && segment.isSingleSpanSegment()) {//判断
        TracingContext.ListenerManager.notifyFinish(finishedSegment)
            if (traceSegment.isIgnore()) { //判断此traceSegment是否忽略
            //produce data to buffer, using the givven {@link BufferStrategy}.
             //把traceSegment 放到 data to buffer, using the givven {@link BufferStrategy}. //mark! 生产消费模型
             //这里会丢弃数据在debug 模式下才能看到log #1
            if (!carrier.produce(traceSegment)) {
                if (driver != null) { //判断消费队列是否为空
                driver.isRunning(channels)//判断channel是否还在
                //Channels of Buffer It contains all buffer data which belongs to this channel. It supports several strategy when buffer
                //is full. The Default is BLOCKING <p> Created by wusheng on 2016/10/25.
                return this.channels.save(data);//
                    int index = dataPartitioner.partition(bufferChannels.length, data);
                    if (BufferStrategy.IF_POSSIBLE.equals(strategy)) {
                    int maxRetryCount = dataPartitioner.maxRetryCount();
                    for (; retryCountDown > 0; retryCountDown--) {
                    if (bufferChannels[index].save(data)) {
                        int i = index.getAndIncrement();
                        if (buffer[i] != null) {//如果cibuffer已被占用,
                        switch (strategy) {//配置策略
                        case BLOCKING://阻塞当前线程
                        boolean isFirstTimeBlocking = true;//是否第一次阻塞
                        while (buffer[i] != null) {
                        if (isFirstTimeBlocking) {
                        isFirstTimeBlocking = false;
                        for (QueueBlockingCallback<T> callback : callbacks) {
                        callback.notify(data);//调用阻塞回调
                        Thread.sleep(1L);
                        //默认策略 返回false 表示没有被消费
                        #1
                        case IF_POSSIBLE:
                        case OVERRIDE:
DataCarrier.DEFAULT.Consumser.0.Thread 线程名
ConsumerThread<T>
    run()
        final List<T> consumeList = new ArrayList<T>(1500);
        while (running) {
        if (!consume(consumeList)) {
            dataSource.obtain(consumeList);
            consumer.consume(consumeList);
            ^TraceSegmentServiceClient#consume(List<TraceSegment> data)
             if (CONNECTED.equals(status)) {
             final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);
             StreamObserver<UpstreamSegment> upstreamSegmentStreamObserver = serviceStub.withDeadlineAfter(Config.Collector.GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collect(new StreamObserver<Commands>()


        Thread.sleep(consumeCycle);


skywalking 客户端启动逻辑
BootService                                                                                                                                             //客户端
    TraceSegmentServiceClient
        ->boot()
            ->carrier = new DataCarrier<TraceSegment>(CHANNEL_SIZE, BUFFER_SIZE);                                                                       // 初始化 CHANNEL_SIZE = 5 个 channel 与 BUFFER_SIZE = 100 个 TraceSegment 的一个 DataCarrier 数据搬运工
                ->this.name = name;
                ->this.bufferSize = EnvUtil.getInt(envPrefix + "_BUFFER_SIZE", bufferSize);
                ->this.channelSize = EnvUtil.getInt(envPrefix + "_CHANNEL_SIZE", channelSize);
                ->channels = new Channels<T>(channelSize, bufferSize, new SimpleRollingPartitioner<T>(), BufferStrategy.BLOCKING);
                    ->this.dataPartitioner = partitioner;
                    ->this.strategy = strategy;
                    ->bufferChannels = new Buffer[channelSize];
                    ->for (int i = 0; i < channelSize; i++) {
                    ->    bufferChannels[i] = new Buffer<T>(bufferSize, strategy);
                    ->}
                    ->size = channelSize * bufferSize;                                                                                                  //缓存大小
            ->carrier.setBufferStrategy(BufferStrategy.IF_POSSIBLE);                                                                                    //设置策略 阻塞还是异步
            ->carrier.consume(this, 1);                                                                                                                 //把TraceSegmentServiceClient的object 放进
                ->this.consume(consumer, num, 20);
                    ->driver = new ConsumeDriver<T>(this.name, this.channels, consumer, num, consumeCycle);												//Thread.sleep(consumeCycle);
                        ->this(channels, num);
                        ->prototype.init();
                        ->for (int i = 0; i < num; i++) {
                        ->  consumerThreads[i] = new ConsumerThread("DataCarrier." + name + ".Consumser." + i + ".Thread", prototype, consumeCycle);    //初始化消费者线程
                        ->  consumerThreads[i].setDaemon(true);
                        ->}
                    ->driver.begin(channels);
    GRPCChannelManager
        ->boot()
            ->grpcServers = Arrays.asList(Config.Collector.BACKEND_SERVICE.split(","));
            ->connectCheckFuture = Executors                                                                                                            //初始化 GRPCChannelManager 的线程
            .newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory("GRPCChannelManager"))
            .scheduleAtFixedRate(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {
              @Override
              public void handle(Throwable t) {
                  logger.error("unexpected exception.", t);
              }
            }), 0, Config.Collector.GRPC_CHANNEL_CHECK_INTERVAL, TimeUnit.SECONDS);
    JVMService
        ->prepare
            ->queue = new LinkedBlockingQueue<JVMMetric>(Config.Jvm.BUFFER_SIZE);
            ->sender = new Sender();
            ->ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(sender);
        ->boot
            ->collectMetricFuture = Executors
                .newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory("JVMService-produce"))
                .scheduleAtFixedRate(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {
                    @Override public void handle(Throwable t) {
                        logger.error("JVMService produces metrics failure.", t);
                    }
                }), 0, 1, TimeUnit.SECONDS);
            ->sendMetricFuture = Executors
                .newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory("JVMService-consume"))
                .scheduleAtFixedRate(new RunnableWithExceptionProtection(sender, new RunnableWithExceptionProtection.CallbackWhenException() {
                    @Override public void handle(Throwable t) {
                        logger.error("JVMService consumes and upload failure.", t);
                    }
                }
                ), 0, 1, TimeUnit.SECONDS);
//OAPServer会在启动时通过 Java SPI 加载这 15个模块
org.apache.skywalking.oap.server.library.module.ModuleDefine

//服务端管理这15个模块
//模块之间存在依赖关系,首先先加载无依赖的项的,不可循环依赖

cluster=org.apache.skywalking.oap.server.core.cluster.ClusterModule
configuration=org.apache.skywalking.oap.server.configuration.api.ConfigurationModule
receiver-clr=org.apache.skywalking.oap.server.receiver.clr.module.CLRModule
query=org.apache.skywalking.oap.server.core.query.QueryModule
storage=org.apache.skywalking.oap.server.core.storage.StorageModule
receiver-trace=org.apache.skywalking.oap.server.receiver.trace.module.TraceModule
envoy-metric=org.apache.skywalking.oap.server.receiver.envoy.EnvoyMetricReceiverModule
istio-telemetry=org.apache.skywalking.oap.server.receiver.istio.telemetry.module.IstioTelemetryReceiverModule
receiver-jvm=org.apache.skywalking.oap.server.receiver.jvm.module.JVMModule
core=org.apache.skywalking.oap.server.core.CoreModule
receiver-sharing-server=org.apache.skywalking.oap.server.receiver.sharing.server.SharingServerModule
service-mesh=org.apache.skywalking.aop.server.receiver.mesh.MeshReceiverModule
alarm=org.apache.skywalking.oap.server.core.alarm.AlarmModule
telemetry=org.apache.skywalking.oap.server.telemetry.TelemetryModule
receiver-register=org.apache.skywalking.oap.server.receiver.register.module.RegisterModule


ModuleProvider//服务端 此类负责加载与实例化 org.apache.skywalking.oap.server.library.module.Service
    ModuleManager
    自定义实现的话,需要提供实现了
    ModuleProvider的
        prepare()
        start()
        notifyAfterCompleted()
        requiredModules[]
        registerServiceImplementation()
        方法的

    manager.init(applicationConfiguration)
    AlarmModuleProvider
        prepare()
            applicationReader = ResourceUtils.read("alarm-settings.yml");
            RulesReader reader = new RulesReader(applicationReader);
            Rules rules = reader.readRules();
            notifyHandler = new NotifyHandler(rules);
                this.rules = rules;
                core = new AlarmCore(rules);
                    runningContext = new HashMap<>();
                            rules.getRules().forEach(rule -> {
                                RunningRule runningRule = new RunningRule(rule);
                                    metricsName = alarmRule.getMetricsName();
                                        this.ruleName = alarmRule.getAlarmRuleName();  //设置规则名alarm-settings 里的rules下以 _rule为结尾的
                                        // Init the empty window for alarming rule.
                                        windows = new ConcurrentHashMap<>();           //初始化窗口
                                        period = alarmRule.getPeriod();                //设置
                                        threshold = new Threshold(alarmRule.getAlarmRuleName()
 alarmRule.getThreshold());
                                        op = OP.get(alarmRule.getOp());
                                        this.countThreshold = alarmRule.getCount();
                                        this.silencePeriod = alarmRule.getSilencePeriod();
                                        this.includeNames = alarmRule.getIncludeNames();
                                        this.formatter = new AlarmMessageFormatter(alarmRule.getMessage());
                                String metricsName = rule.getMetricsName();
                                List<RunningRule> runningRules = runningContext.computeIfAbsent(metricsName
 key -> new ArrayList<>());
                                runningRules.add(runningRule);
                            });
            notifyHandler.init(new AlarmStandardPersistence());
            this.registerServiceImplementation(MetricsNotify.class, notifyHandler); //注册模块的 Service

